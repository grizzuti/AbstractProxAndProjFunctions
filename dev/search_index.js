var documenterSearchIndex = {"docs":
[{"location":"functions/#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"functions/#General-proximal/projection-functionalities","page":"Main functions","title":"General proximal/projection functionalities","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.prox-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.prox","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the proximal operator mathrmprox_lambdag(mathbfy).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.prox-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}, AbstractArgminOptions}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.prox","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the proximal operator with specified options.\n\nSee prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"proj(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.proj-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.proj","text":"proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the projection operator mathrmproj_lambdag(mathbfy).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"proj(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.proj-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}, AbstractArgminOptions}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.proj","text":"proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the projection operator with specified options.\n\nSee proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\n\n\n\n\n","category":"method"},{"location":"functions/#Iterative-solver-utilities","page":"Main functions","title":"Iterative solver utilities","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"exact_argmin","category":"page"},{"location":"functions/#AbstractProximableFunctions.exact_argmin","page":"Main functions","title":"AbstractProximableFunctions.exact_argmin","text":"exact_argmin()\n\nReturns exact optimization options for the computation of proximal/projection operators. It might results in an error if the regularization functional does not implement analytically-defined proximal/projection operators (e.g. TV!).\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"FISTA_options","category":"page"},{"location":"functions/#AbstractProximableFunctions.FISTA_options","page":"Main functions","title":"AbstractProximableFunctions.FISTA_options","text":"FISTA_options(L; Nesterov=true,\n                 reset_counter=nothing,\n                 niter=nothing,\n                 verbose=false,\n                 fun_history=false)\n\nReturns FISTA iterative solver options for the general optimization problem:\n\nmin_mathbfxf(mathbfx)+g(mathbfx)\n\nwhere g is a \"proximable\" function. It can be used to define options for the proximal or projection operators.\n\nThe parameter L ideally should be chosen as LgemathrmLipnabla f (=Lipschitz constant of the gradient) and is problem specific.\n\nNesterov acceleration is set by Nesterov=true, while reset_counter is the number of iteration after which the Nesterov momentum is reset. The total number of iterations is determined by niter.\n\nFor debugging, set verbose=true and/or fun_history=true (the latter allows storing the history of f(mathbfx), which can be retrieved by fun_history(options) after minimization).\n\nImportant note\n\nWhen setting the options for proximal or projection operators, follow the recommendations for each specific proximal function on how to choose L. The underlying optimization may be based on algebraic reformulations of the optimization problem min_mathbfx12mathbfx-mathbfy^2+lambdag(mathbfx), so the assumption that f(mathbfx)=12mathbfx-mathbfy^2 is not generally correct. This note is relevant when computing the proximal operator of WeightedProximalFunction's for which the problem min_mathbfx12mathbfx-mathbfy^2+lambdag(Amathbfx) is transformed to min_mathbfp12lambda A^*mathbfp-mathbfy^2+lambda g^*(mathbfp). The Lipschitz constant in this case should be lambda^2rho(A). For convenience of use, however, the Lipschitz constant is expected to be just rho(A).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Implemented-proximable-functions","page":"Main functions","title":"Implemented proximable functions","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"LinearAlgebra.norm(T::DataType, N::Number, P::Number)","category":"page"},{"location":"functions/#LinearAlgebra.norm-Tuple{DataType, Number, Number}","page":"Main functions","title":"LinearAlgebra.norm","text":"LinearAlgebra.norm(T::DataType, N::Number, P::Number)\n\nReturn the proximable function g(mathbfx)=mathbfx_p where pin12infty.\n\nMust specify the element type T and array dimension N of the input array.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"mixed_norm(T::DataType, D::Number, N1::Number, N2::Number)","category":"page"},{"location":"functions/#AbstractProximableFunctions.mixed_norm-Tuple{DataType, Number, Number, Number}","page":"Main functions","title":"AbstractProximableFunctions.mixed_norm","text":"mixed_norm(T::DataType, D::Number, N1::Number, N2::Number)\n\nReturn the mixed-norm proximable function. For a D+1-dimensional input array mathbfx_i_1ldotsi_D^i_D+1, it represents the functional g(mathbfx)=(i_1ldotsi_D)mapstomathbfx_i_1ldotsi_D^_ell^N_1_ell^N_2. Implementations are available for N_1=2, N_2in12infty.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We show some of the functionalities of AbstractProximableFunctions with a simple tutorial, focus on a 2D denoising problem. Before starting, make sure the package is installed (see Section Installation instructions). For this tutorial, we also need FFTW (Fourier transform), TestImages, PyPlot. To install,","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"@(v1.8) pkg> add FFTW, TestImages, PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Here, we use PyPlot for image visualization, but many other packages may fit the bill.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To load all the needed packages:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"using LinearAlgebra, AbstractLinearOperators, AbstractProximableFunctions, FFTW, PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"For our denoising exercise, we initialize a noisy image, which consists of a simple complex plane wave:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Setting noisy data (plane wave)\nn = (256, 256)   # Image size\nfov = (1f0, 1f0) # Field-of-view\nh = fov./n       # Spacing\nx = range(-fov[1]/2, fov[1]/2; length=n[1]); y = range(-fov[2]/2, fov[2]/2; length=n[2]); # Cartesian coordinates\nk = (0.01f0, 0.02f0)./(2f0.*h) # Wavenumber\nx_clean = exp.(1im*2*Float32(pi)*(k[1]*reshape(x, :, 1).+k[2]*reshape(y, 1, :))) # Plane wave\nx_noisy = x_clean.+0.5f0*randn(ComplexF32, n) # Adding noise","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We study the effect of three regularization functionals: ell^1, ell^2, and ell^infty:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Initializing regularization functionals (w/out transform)\ng1   = norm(ComplexF32, 2, 1)   # ℓ1 norm for 2D (complex) images\ng2   = norm(ComplexF32, 2, 2)   # ℓ2 norm for 2D (complex) images\ngInf = norm(ComplexF32, 2, Inf) # ℓInf norm for 2D (complex) images","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To perform denoising, e.g. find the solution of the optimization problem min_mathbfxfrac12mathbfx-mathbfy^2+lambda g(mathbfx), we need to set a weight lambda and make a call to proximal operator:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Denoising\nλ1 = 0.5f0*norm(x_clean-x_noisy)^2/g1(x_clean)\nx1 = prox(x_noisy, λ1, g1)\nλ2 = 0.5f0*norm(x_clean-x_noisy)^2/g2(x_clean)\nx2 = prox(x_noisy, λ2, g2)\nλInf = 0.5f0*norm(x_clean-x_noisy)^2/gInf(x_clean)\nxInf = prox(x_noisy, λInf, gInf)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"The results of the denoising problem will not look particularly good, because we are not exploiting enough prior knowledge of the solution.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"A more sensible way to go about relies on the sparsity of the solution in some domain. For this purpose, we define the Fourier transform:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Set Fourier transform as a linear operator (wrapper via AbstractLinearOperators)\nC = Float32(sqrt(prod(n)))\nF = linear_operator(ComplexF32, n, n, x -> ifftshift(fft(x))/C, # Forward evaluation\n                                      x̂ -> C*ifft(fftshift(x̂))) # Adjoint evaluation","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We can compose the Fourier transform with the previous regularization functionals:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Transform-based regularization functionals\ng1_F = g1∘F\ng2_F = g2∘F\ngInf_F = gInf∘F","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Performing denoising with weighted regularization is tantamount to solve the optimization problem","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"min_mathbfxdfrac12mathbfx-mathbfy^2+lambda g(Amathbfx)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"where A is a linear operator. By default, in AbstractProximalFunctions this problem is reformulated in dual form:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"min_mathbfpdfrac12lambda A^*mathbfp-mathbfy^2+lambda g^*(mathbfp)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"where g^* is the convex conjugate of g. Primal mathbfx and dual variables mathbfp are related by mathbfx=mathbfy-lambda A^*mathbfp.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"In order to solve this problem, we resort to a FISTA iterative solver. To specify FISTA, we have to know the Lipschitz constant of nabla f where f(mathbfx)=dfrac12lambda A^*mathbfp-mathbfy^2, which is mathrmLipnabla f=lambda^2rho(A) with rho being the spectral radius. Importantly, whenever computing the prox of WeighthedProximalFunctions, FISTA_options actually expects mathrmLipnabla f=rho(A). Hence:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Minimization options\noptions = FISTA_options(1f0;           # Lipschitz constant of ∇f(x), in this case equivalent to spectral norm of F\n                             niter=10) # Number of iteration","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Now, everything is set up to run the proximal computations:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Denoising (w/ Fourier transform)\nλ1_F = 0.5f0*norm(x_clean-x_noisy)^2/g1_F(x_clean)\nx1_F = prox(x_noisy, λ1_F, g1_F, options)\nλ2_F = 0.5f0*norm(x_clean-x_noisy)^2/g2_F(x_clean)\nx2_F = prox(x_noisy, λ2_F, g2_F, options)\nλInf_F = 0.5f0*norm(x_clean-x_noisy)^2/gInf_F(x_clean)\nxInf_F = prox(x_noisy, λInf_F, gInf_F, options)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We expect the transform-based ell^1 to performed the best. In order to compare the results:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Plot\nvmin = -1f0\nvmax =  1f0\nfigure()\nsubplot(2,5,1)\nimshow(real(x_noisy); vmin=vmin, vmax=vmax)\ntitle(\"Noisy phantom\")\naxis(\"off\")\nsubplot(2,5,2)\nimshow(real(xInf); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^{\\infty}$ denoising\")\naxis(\"off\")\nsubplot(2,5,3)\nimshow(real(x2); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^2$ denoising\")\naxis(\"off\")\nsubplot(2,5,4)\nimshow(real(x1); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^1$ denoising\")\naxis(\"off\")\nsubplot(2,5,5)\nimshow(real(x_clean); vmin=vmin, vmax=vmax)\ntitle(\"Ground truth\")\naxis(\"off\")\nsubplot(2,5,6)\nimshow(real(x_noisy); vmin=vmin, vmax=vmax)\ntitle(\"Noisy phantom\")\naxis(\"off\")\nsubplot(2,5,7)\nimshow(real(xInf_F); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^{\\infty}$ denoising (w/ transform)\")\naxis(\"off\")\nsubplot(2,5,8)\nimshow(real(x2_F); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^2$ denoising (w/ transform)\")\naxis(\"off\")\nsubplot(2,5,9)\nimshow(real(x1_F); vmin=vmin, vmax=vmax)\ntitle(L\"$\\ell^1$ denoising (w/ transform)\")\naxis(\"off\")\nsubplot(2,5,10)\nimshow(real(x_clean); vmin=vmin, vmax=vmax)\ntitle(\"Ground truth\")\naxis(\"off\")","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the Julia REPL, simply type ] and","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(@v1.8) pkg> add https://github.com/grizzuti/AbstractLinearOperators.git, add https://github.com/grizzuti/AbstractProximableFunctions.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note that, since AbstractProximableFunctions has unregistered dependencies, we need to explicitly install also the package AbstractLinearOperators.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provide some general abstract utilities for the computation of proximal and projection operators for the class of \"proximable\" functions (functions for which these operators can be implemented efficiently).","category":"page"},{"location":"#Proximal-and-projection-operators","page":"Introduction","title":"Proximal and projection operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main functionalities provided by this package are related to the computation of the proximal and projection operators. For a generic (convex) functional g, the proximal operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmprox_lambdag(mathbfw)=argmin_mathbfudfrac12mathbfu-mathbfw^2+lambdag(mathbfu)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly, the projection operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmproj_varepsilon g(mathbfw)=argmin_g(mathbfu)levarepsilondfrac12mathbfu-mathbfw^2","category":"page"},{"location":"#Why-AbstractProximableFunctions?","page":"Introduction","title":"Why AbstractProximableFunctions?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Several properties of the proximal operators can be \"abstractified\", in a Julian sense, and are available once some basic components of the data type of interest are properly defined. As a trivial example, if a function g::AbstractProximableFunction implements a proximal operator method prox(x, λ, g, ...), then the proximal operator of its convex conjugate g (see [1]) is prox(q, λ, ḡ, ...)=prox(q/λ, 1/λ, g, ...). A more interesting and ubiquitous example is when we want to combine a proximable function with a linear operator, e.g. gA, which gives rise to a WeightedProximableFunction with some embedded default behavior.","category":"page"},{"location":"#Related-publications","page":"Introduction","title":"Related publications","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Parikh, N., and Boyd, S., (2014). Proximal Algorithms, _Foundations and Trends in Optimization _, 1(3), 127-239, doi:10.1561/2400000003","category":"page"}]
}
